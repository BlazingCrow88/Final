/* ===================================
   SWIPER LIBRARY (COMPREHENSIVE VERSION)
   File: assets/js/vendors/swiper.min.js
   Version: 8.4.7 (Adapted)
   Note: For production, use the official Swiper library from swiperjs.com
   =================================== */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Swiper = factory());
})(this, (function () { 'use strict';

    function isObject(obj) {
        return obj !== null && obj && typeof obj === 'object' && obj.constructor === Object;
    }

    function extend(target, src) {
        Object.keys(src).forEach(key => {
            if (typeof src[key] === 'undefined') return;
            if (isObject(src[key]) && isObject(target[key])) {
                extend(target[key], src[key]);
            } else {
                target[key] = src[key];
            }
        });
    }

    function getElement(selector, context = document) {
        return typeof selector === 'string' ? context.querySelector(selector) : selector;
    }

    function getElements(selector, context = document) {
        return typeof selector === 'string' ? [...context.querySelectorAll(selector)] : [selector];
    }

    function addClass(el, className) {
        if (typeof className === 'undefined') return;
        const classes = className.split(' ');
        classes.forEach(c => c && el.classList.add(c));
    }

    function removeClass(el, className) {
        if (typeof className === 'undefined') return;
        const classes = className.split(' ');
        classes.forEach(c => c && el.classList.remove(c));
    }

    function hasClass(el, className) {
        return el.classList.contains(className);
    }

    function getTranslate(el, axis = 'x') {
        const matrix = getComputedStyle(el).transform;
        if (matrix === 'none') return 0;
        const matrixValues = matrix.match(/matrix.*\((.+)\)/)[1].split(', ');
        if (axis === 'x') return parseFloat(matrixValues[4] || 0);
        return parseFloat(matrixValues[5] || 0);
    }

    function setTranslate(el, value) {
        const transformString = `translate3d(${value}px, 0px, 0px)`;
        el.style.transform = transformString;
    }

    function getTransition(el) {
        return parseFloat(getComputedStyle(el).transitionDuration.replace('s', '')) * 1000;
    }

    function setTransition(el, duration) {
        el.style.transitionDuration = `${duration}ms`;
    }

    function nextTick(callback, delay = 0) {
        return setTimeout(callback, delay);
    }

    function elementOffset(el) {
        const rect = el.getBoundingClientRect();
        const win = el.ownerDocument.defaultView;
        return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
        };
    }

    function elementParents(el, selector) {
        const parents = [];
        let parent = el.parentElement;
        while (parent) {
            if (selector) {
                if (parent.matches(selector)) parents.push(parent);
            } else {
                parents.push(parent);
            }
            parent = parent.parentElement;
        }
        return parents;
    }

    function elementChildren(el, selector) {
        const children = [...el.children];
        return selector ? children.filter(child => child.matches(selector)) : children;
    }

    function createElement(tag, classes) {
        const el = document.createElement(tag);
        if (classes) addClass(el, classes);
        return el;
    }

    function deleteProps(obj) {
        const object = obj;
        Object.keys(object).forEach(key => {
            try {
                object[key] = null;
            } catch (e) {
                // ignore
            }
            try {
                delete object[key];
            } catch (e) {
                // ignore
            }
        });
    }

    function uniqueClasses(...classes) {
        const classNames = [];
        classes.forEach(c => {
            if (typeof c === 'string' && classNames.indexOf(c) < 0) classNames.push(c);
        });
        return classNames.join(' ');
    }

    // Core Swiper Class
    class Swiper {
        constructor(container, params = {}) {
            this.container = getElement(container);
            if (!this.container) {
                console.error('Swiper container element not found');
                return;
            }

            // Default parameters
            this.defaults = {
                init: true,
                direction: 'horizontal',
                oneWayMovement: false,
                touchEventsTarget: 'wrapper',
                initialSlide: 0,
                speed: 300,
                cssMode: false,
                updateOnWindowResize: true,
                resizeObserver: true,
                nested: false,
                createElements: false,
                enabled: true,
                focusableElements: 'input, select, option, textarea, button, video, label',
                // Wrapper
                width: null,
                height: null,
                // Slides
                slidesPerView: 1,
                slidesPerGroup: 1,
                slidesPerGroupSkip: 0,
                slidesPerGroupAuto: false,
                centeredSlides: false,
                centeredSlidesBounds: false,
                slidesOffsetBefore: 0,
                slidesOffsetAfter: 0,
                normalizeSlideIndex: true,
                centerInsufficientSlides: false,
                // Disable
                watchOverflow: true,
                // Round length
                roundLengths: false,
                // Touches
                touchRatio: 1,
                touchAngle: 45,
                simulateTouch: true,
                shortSwipes: true,
                longSwipes: true,
                longSwipesRatio: 0.5,
                longSwipesMs: 300,
                followFinger: true,
                allowTouchMove: true,
                threshold: 5,
                touchMoveStopPropagation: false,
                touchStartPreventDefault: true,
                touchStartForcePreventDefault: false,
                touchReleaseOnEdges: false,
                // Unique Navigation Elements
                uniqueNavElements: true,
                // Resistance
                resistance: true,
                resistanceRatio: 0.85,
                // Progress
                watchSlidesProgress: false,
                // Cursor
                grabCursor: false,
                // Clicks
                preventClicks: true,
                preventClicksPropagation: true,
                slideToClickedSlide: false,
                // loop
                loop: false,
                loopedSlides: null,
                loopPreventsSliding: true,
                // rewind
                rewind: false,
                // Swiping/no swiping
                allowSlidePrev: true,
                allowSlideNext: true,
                swipeHandler: null,
                noSwiping: true,
                noSwipingClass: 'swiper-no-swiping',
                noSwipingSelector: null,
                // Passive Listeners
                passiveListeners: true,
                maxBackfaceHiddenSlides: 10,
                // NS
                containerModifierClass: 'swiper-',
                slideClass: 'swiper-slide',
                slideActiveClass: 'swiper-slide-active',
                slideVisibleClass: 'swiper-slide-visible',
                slideNextClass: 'swiper-slide-next',
                slidePrevClass: 'swiper-slide-prev',
                wrapperClass: 'swiper-wrapper',
                lazyPreloaderClass: 'swiper-lazy-preloader',
                lazyPreloadPrevNext: 0,
                // Callbacks
                runCallbacksOnInit: true,
                // Internals
                _emitClasses: false
            };

            this.params = {...this.defaults, ...params};
            this.originalParams = {...this.params};
            this.passedParams = params;

            // Initialize
            this.$ = {
                el: this.container,
                wrapperEl: null,
                slides: [],
                cache: new Map()
            };

            this.isElement = this.container.constructor === HTMLElement;
            
            // Properties
            this.enabled = this.params.enabled;
            this.allowSlideNext = this.params.allowSlideNext;
            this.allowSlidePrev = this.params.allowSlidePrev;
            this.swipeDirection = null;
            this.touches = {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            };

            this.translate = 0;
            this.progress = 0;
            this.velocity = 0;
            this.animating = false;
            this.allowMomentumBounce = false;
            this.currentBreakpoint = null;
            this.destroyed = false;

            // Initialize
            if (this.params.init) {
                this.init();
            }
        }

        init() {
            if (this.initialized) return this;
            this.emit('beforeInit');

            // Initialize modules
            this.initContainer();
            this.initWrapper();
            this.initSlides();
            this.initEvents();
            this.initBreakpoints();
            this.initNavigation();
            this.initPagination();
            this.initScrollbar();
            this.initAutoplay();
            this.initLazy();

            this.initialized = true;
            this.emit('init');
            return this;
        }

        initContainer() {
            const {params} = this;
            addClass(this.container, params.containerModifierClass + params.direction);
            
            if (params.freeMode && params.freeMode.enabled) {
                addClass(this.container, params.containerModifierClass + 'free-mode');
            }

            if (params.autoHeight) {
                addClass(this.container, params.containerModifierClass + 'autoheight');
            }

            if (params.parallax || (params.watchSlidesVisibility && params.watchSlidesProgress)) {
                addClass(this.container, params.containerModifierClass + 'watch-progress');
            }

            if (params.centeredSlides) {
                addClass(this.container, params.containerModifierClass + 'centered');
            }

            if (params.cssMode) {
                addClass(this.container, params.containerModifierClass + 'css-mode');
            }
        }

        initWrapper() {
            this.wrapper = this.container.querySelector(`.${this.params.wrapperClass}`);
            if (!this.wrapper) {
                this.wrapper = createElement('div', this.params.wrapperClass);
                this.container.appendChild(this.wrapper);
            }
            this.$.wrapperEl = this.wrapper;
        }

        initSlides() {
            this.slides = [...this.wrapper.querySelectorAll(`.${this.params.slideClass}`)];
            this.$.slides = this.slides;
            this.snapGrid = [];
            this.slidesGrid = [];
            this.slidesSizesGrid = [];

            this.updateSlidesClasses();
            this.updateSize();
            this.updateSlides();
            this.updateProgress();
            this.updateSlidesClasses();
        }

        updateSize() {
            let width, height;
            const {container} = this;

            if (typeof this.params.width !== 'undefined' && this.params.width !== null) {
                width = this.params.width;
            } else {
                width = container.clientWidth;
            }

            if (typeof this.params.height !== 'undefined' && this.params.height !== null) {
                height = this.params.height;
            } else {
                height = container.clientHeight;
            }

            if ((width === 0 && this.isHorizontal()) || (height === 0 && this.isVertical())) {
                return;
            }

            // Subtract paddings
            width = width - parseInt(getComputedStyle(container)['padding-left'] || 0) - parseInt(getComputedStyle(container)['padding-right'] || 0);
            height = height - parseInt(getComputedStyle(container)['padding-top'] || 0) - parseInt(getComputedStyle(container)['padding-bottom'] || 0);

            this.width = width;
            this.height = height;
            this.size = this.isHorizontal() ? this.width : this.height;
        }

        updateSlides() {
            const {params} = this;
            const {wrapper, slides} = this;

            this.virtualSize = 0;
            this.slidesGrid = [];
            this.snapGrid = [];
            this.slidesSizesGrid = [];

            let spaceBetween = params.spaceBetween;
            let slidePosition = -params.slidesOffsetBefore;
            let i;
            let prevSlideSize = 0;
            let index = 0;

            if (typeof this.size === 'undefined') return;

            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
                spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * this.size;
            }

            this.virtualSize = -spaceBetween;

            // Reset margins
            slides.forEach(slideEl => {
                if (this.isHorizontal()) {
                    slideEl.style.marginLeft = '';
                    slideEl.style.marginBottom = '';
                    slideEl.style.marginTop = '';
                } else {
                    slideEl.style.marginRight = '';
                    slideEl.style.marginBottom = '';
                    slideEl.style.marginLeft = '';
                }
            });

            if (params.centeredSlides && params.cssMode) {
                this.wrapper.style.setProperty('--swiper-centered-offset-before', '');
                this.wrapper.style.setProperty('--swiper-centered-offset-after', '');
            }

            const gridEnabled = params.grid && params.grid.rows > 1 && this.grid;
            if (gridEnabled) {
                this.grid.initSlides(slides.length);
            }

            // Calc slides
            let slideSize;
            const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
                return typeof params.breakpoints[key].slidesPerView !== 'undefined';
            }).length > 0;

            for (i = 0; i < slides.length; i += 1) {
                slideSize = 0;
                const slide = slides[i];
                if (gridEnabled) {
                    this.grid.updateSlide(i, slide, slides.length, this.getDirectionLabel);
                }
                if (getComputedStyle(slide).display === 'none') continue;
                if (params.slidesPerView === 'auto') {
                    if (shouldResetSlideSize) {
                        slides[i].style[this.getDirectionLabel('width')] = ``;
                    }
                    const slideStyles = getComputedStyle(slide);
                    const currentTransform = slide.style.transform;
                    const currentWebKitTransform = slide.style.webkitTransform;
                    if (currentTransform) {
                        slide.style.transform = 'none';
                    }
                    if (currentWebKitTransform) {
                        slide.style.webkitTransform = 'none';
                    }
                    if (params.roundLengths) {
                        slideSize = this.isHorizontal() ? slide.offsetWidth : slide.offsetHeight;
                    } else {
                        const width = parseFloat(slideStyles.width || 0);
                        const paddingLeft = parseFloat(slideStyles.paddingLeft || 0);
                        const paddingRight = parseFloat(slideStyles.paddingRight || 0);
                        const marginLeft = parseFloat(slideStyles.marginLeft || 0);
                        const marginRight = parseFloat(slideStyles.marginRight || 0);
                        const boxSizing = slideStyles.getPropertyValue('box-sizing');
                        if (boxSizing && boxSizing === 'border-box') {
                            slideSize = width + marginLeft + marginRight;
                        } else {
                            const {clientWidth, offsetWidth} = slide;
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) {
                        slide.style.transform = currentTransform;
                    }
                    if (currentWebKitTransform) {
                        slide.style.webkitTransform = currentWebKitTransform;
                    }
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (this.size - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) {
                        slides[i].style[this.getDirectionLabel('width')] = `${slideSize}px`;
                    }
                }
                if (slides[i]) {
                    slides[i].swiperSlideSize = slideSize;
                }
                this.slidesSizesGrid.push(slideSize);

                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - this.size / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - this.size / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index) % params.slidesPerGroup === 0) this.snapGrid.push(slidePosition);
                    this.slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(this.params.slidesPerGroupSkip, index)) % this.params.slidesPerGroup === 0) this.snapGrid.push(slidePosition);
                    this.slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }

                this.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }

            this.virtualSize = Math.max(this.virtualSize - spaceBetween, 0) || 0;

            if (params.loop) {
                this.loopCreate();
            }

            if (!params.cssMode || params.speed === 0) {
                this.setTranslate(this.translate);
            }

            this.emit('slidesUpdated');
        }

        updateProgress(translate) {
            const translateValue = typeof translate === 'undefined' ? (this.translate || 0) : translate;
            const slideSize = this.size;
            let progress;
            let progressLoop = 0;
            const wasBeginning = this.isBeginning;
            const wasEnd = this.isEnd;
            if (slideSize === 0) {
                progress = 0;
            } else {
                progress = Math.min(Math.max((translateValue) / -slideSize, 0), 1);
            }
            if (this.params.loop) {
                const firstSlideProgress = this.getSlideProgress(this.slides[0]);
                const lastSlideProgress = this.getSlideProgress(this.slides[this.slides.length - 1]);
                const firstSlideTranslate = this.getSlideTranslate(this.slides[0]);
                const lastSlideTranslate = this.getSlideTranslate(this.slides[this.slides.length - 1]);
                if (firstSlideTranslate <= 0 && translateValue <= firstSlideTranslate) {
                    progressLoop = (firstSlideTranslate - translateValue) / firstSlideTranslate;
                }
                if (lastSlideTranslate >= 0 && translateValue >= lastSlideTranslate) {
                    progressLoop = (translateValue - lastSlideTranslate) / lastSlideTranslate;
                }
            }
            Object.assign(this, {
                progress,
                progressLoop,
                isBeginning: progress <= 0,
                isEnd: progress >= 1
            });
            if (wasBeginning !== this.isBeginning || wasEnd !== this.isEnd) {
                this.emit('reachBeginning reachEnd');
            }
            if (this.params.watchSlidesProgress || (this.params.centeredSlides && this.params.autoHeight)) this.updateSlidesProgress(translateValue);
            this.emit('progress', progress);
        }

        updateSlidesProgress(translate) {
            const swiper = this;
            const translateValue = typeof translate === 'undefined' ? (swiper.translate || 0) : translate;
            if (swiper.slides.length === 0) return;
            if (typeof swiper.slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
            let offsetCenter = -translateValue;
            if (swiper.rtlTranslate) offsetCenter = translateValue;

            // Visible Slides
            swiper.slides.forEach(slideEl => {
                slideEl.classList.remove(swiper.params.slideVisibleClass);
            });

            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];

            for (let i = 0; i < swiper.slides.length; i += 1) {
                const slide = swiper.slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (swiper.params.cssMode && swiper.params.centeredSlides) {
                    slideOffset -= swiper.slides[0].swiperSlideOffset;
                }
                const slideProgress = (offsetCenter + (swiper.params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + swiper.params.spaceBetween);
                const originalSlideProgress = (offsetCenter - swiper.snapGrid[0] + (swiper.params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + swiper.params.spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1) || (slideAfter > 1 && slideAfter <= swiper.size) || (slideBefore <= 0 && slideAfter >= swiper.size);
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slide.classList.add(swiper.params.slideVisibleClass);
                }
                slide.progress = swiper.rtlTranslate ? -slideProgress : slideProgress;
                slide.originalProgress = swiper.rtlTranslate ? -originalSlideProgress : originalSlideProgress;
            }
        }

        updateSlidesClasses() {
            const {slides, params, activeIndex, realIndex} = this;
            const suffixFree = this.virtual && params.virtual.enabled;
            
            slides.forEach(slideEl => {
                slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            });

            let activeSlide;
            if (suffixFree) {
                activeSlide = this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${realIndex}`)[0];
            } else {
                activeSlide = slides[activeIndex];
            }

            if (activeSlide) {
                // Active classes
                activeSlide.classList.add(params.slideActiveClass);

                // Next Slide
                let nextSlide = activeSlide.nextElementSibling;
                if (params.loop && !nextSlide) {
                    nextSlide = slides[0];
                }
                if (nextSlide) {
                    nextSlide.classList.add(params.slideNextClass);
                }

                // Prev Slide
                let prevSlide = activeSlide.previousElementSibling;
                if (params.loop && !prevSlide) {
                    prevSlide = slides[slides.length - 1];
                }
                if (prevSlide) {
                    prevSlide.classList.add(params.slidePrevClass);
                }
            }

            this.emitSlidesClasses();
        }

        updateActiveIndex(newActiveIndex) {
            const {snapGrid, params} = this;
            const translate = this.rtlTranslate ? this.translate : -this.translate;
            const {slidesGrid} = this;
            const snapIndex = Math.floor(snapGrid.length / 2);
            const translateMax = this.maxTranslate();

            let activeIndex;
            let snapIndex2;

            if (typeof newActiveIndex === 'undefined') {
                for (let i = 0; i < snapGrid.length; i += 1) {
                    if (typeof snapGrid[i + 1] !== 'undefined') {
                        if (translate >= snapGrid[i] && translate < snapGrid[i + 1] - (snapGrid[i + 1] - snapGrid[i]) / 2) {
                            activeIndex = i;
                        } else if (translate >= snapGrid[i] && translate < snapGrid[i + 1]) {
                            activeIndex = i + 1;
                        }
                    } else if (translate >= snapGrid[i]) {
                        activeIndex = i;
                    }
                }

                // Normalize slideIndex
                if (params.normalizeSlideIndex) {
                    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
                }
            } else {
                activeIndex = newActiveIndex;
            }

            if (slidesGrid.indexOf(translate) >= 0) {
                snapIndex2 = slidesGrid.indexOf(translate);
            } else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex2 = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }

            if (snapIndex2 >= snapGrid.length) snapIndex2 = snapGrid.length - 1;

            if (activeIndex === this.activeIndex) {
                if (snapIndex2 !== this.snapIndex) {
                    this.snapIndex = snapIndex2;
                    this.emit('snapIndexChange');
                }
                return;
            }

            // Get real index
            const realIndex = parseInt(this.slides[activeIndex] && this.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);

            Object.assign(this, {
                snapIndex: snapIndex2,
                realIndex,
                previousIndex: this.activeIndex,
                activeIndex
            });

            this.emit('activeIndexChange');
            this.emit('snapIndexChange');
            if (this.previousIndex !== activeIndex) {
                this.emit('slideChangeTransitionStart');
            }
            this.emit('slideChange');
        }

        // Translate methods
        minTranslate() {
            return (-this.snapGrid[0]);
        }

        maxTranslate() {
            return (-this.snapGrid[this.snapGrid.length - 1]);
        }

        translateTo(translate, speed, runCallbacks = true, translateBounds = true, internal) {
            if (typeof translate === 'undefined') {
                translate = 0;
            }
            if (typeof speed === 'undefined') {
                speed = this.params.speed;
            }

            const {params, wrapper} = this;

            if (translateBounds) {
                if (translate < this.minTranslate()) {
                    translate = this.minTranslate();
                } else if (translate > this.maxTranslate()) {
                    translate = this.maxTranslate();
                }
            }

            // Update progress
            this.updateProgress(translate);

            if (params.cssMode) {
                const isH = this.isHorizontal();
                if (speed === 0) {
                    wrapper[isH ? 'scrollLeft' : 'scrollTop'] = -translate;
                } else {
                    wrapper.scrollTo(
                        isH ? -translate : 0,
                        isH ? 0 : -translate
                    );
                }
                return true;
            }

            if (speed === 0) {
                setTransition(wrapper, 0);
                setTranslate(wrapper, translate);
                if (runCallbacks) {
                    this.emit('beforeTransitionStart', speed, internal);
                    this.emit('transitionEnd');
                }
            } else {
                setTransition(wrapper, speed);
                setTranslate(wrapper, translate);
                if (runCallbacks) {
                    this.emit('beforeTransitionStart', speed, internal);
                    this.emit('transitionStart');
                }
                if (!this.animating) {
                    this.animating = true;
                    if (!this.onWrapperTransitionEnd) {
                        this.onWrapperTransitionEnd = function transitionEnd(e) {
                            if (!this || this.destroyed) return;
                            if (e.target !== this) return;
                            this.wrapper.removeEventListener('transitionend', this.onWrapperTransitionEnd);
                            this.onWrapperTransitionEnd = null;
                            delete this.onWrapperTransitionEnd;
                            if (runCallbacks) {
                                this.emit('transitionEnd');
                            }
                        };
                    }
                    wrapper.addEventListener('transitionend', this.onWrapperTransitionEnd);
                }
            }

            return true;
        }

        getTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
            const {params, rtlTranslate, translate, wrapper} = this;

            if (params.virtualTranslate) {
                return rtlTranslate ? -translate : translate;
            }
            if (params.cssMode) {
                return translate;
            }

            let currentTranslate = getTranslate(wrapper, axis);
            if (rtlTranslate) currentTranslate = -currentTranslate;

            return currentTranslate || 0;
        }

        setTranslate(translate, byController) {
            const {
                rtlTranslate, params, wrapper, progress
            } = this;
            let x = 0;
            let y = 0;

            if (this.isHorizontal()) {
                x = rtlTranslate ? translate : -translate;
            } else {
                y = -translate;
            }

            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }

            this.previousTranslate = this.translate;
            this.translate = this.isHorizontal() ? x : y;

            if (params.cssMode) {
                wrapper[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = this.isHorizontal() ? -x : -y;
            } else if (!params.virtualTranslate) {
                setTranslate(wrapper, `translate3d(${x}px, ${y}px, 0px)`);
            }

            // Check if we need to update progress
            let newProgress;
            const translatesDiff = this.maxTranslate() - this.minTranslate();
            if (translatesDiff === 0) {
                newProgress = 0;
            } else {
                newProgress = (translate - this.minTranslate()) / translatesDiff;
            }
            if (newProgress !== progress) {
                this.updateProgress(translate);
            }

            this.emit('setTranslate', this.translate, byController);
        }

        setTransition(duration, byController) {
            const {wrapper} = this;
            if (!this.params.cssMode) {
                setTransition(wrapper, duration);
            }
            this.emit('setTransition', duration, byController);
        }

        // Slides methods
        slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
            if (typeof index === 'string') {
                index = parseInt(index, 10);
            }

            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;

            const {
                params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapper,
                enabled
            } = this;

            if ((!enabled && !internal && !initial) || this.destroyed) return this;

            const skip = Math.min(this.params.slidesPerGroupSkip, slideIndex);
            const snapIndex = skip + Math.floor((slideIndex - skip) / this.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

            const translate = -snapGrid[snapIndex];
            // Normalize slideIndex
            if (params.normalizeSlideIndex) {
                for (let i = 0; i < slidesGrid.length; i += 1) {
                    const normalizedTranslate = -Math.floor(translate * 100);
                    const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                    const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                    if (typeof slidesGrid[i + 1] !== 'undefined') {
                        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                            slideIndex = i;
                        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                            slideIndex = i + 1;
                        }
                    } else if (normalizedTranslate >= normalizedGrid) {
                        slideIndex = i;
                    }
                }
            }

            // Directions locks
            if (!this.allowSlideNext && translate < this.translate && translate < this.minTranslate()) {
                return false;
            }
            if (!this.allowSlidePrev && translate > this.translate && translate > this.maxTranslate()) {
                if ((activeIndex || 0) !== slideIndex) return false;
            }

            // Update Index
            if (slideIndex !== activeIndex) {
                if (!initial && this.params.history) {
                    this.updateHistory();
                }
            }

            if (speed === 0 || this.params.speed === 0) {
                this.setTransition(0);
                this.setTranslate(translate);
                this.updateActiveIndex(slideIndex);
                this.updateSlidesClasses();
                this.emit('beforeTransitionStart', speed, internal);
                this.transitionStart(runCallbacks, internal);
                this.transitionEnd(runCallbacks, internal);
                return this;
            }

            this.setTransition(speed);
            this.setTranslate(translate);
            this.updateActiveIndex(slideIndex);
            this.updateSlidesClasses();
            this.emit('beforeTransitionStart', speed, internal);
            this.transitionStart(runCallbacks, internal);

            if (!this.animating) {
                this.animating = true;
                if (!this.onSlideToWrapperTransitionEnd) {
                    this.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!this || this.destroyed) return;
                        if (e.target !== this) return;
                        this.wrapper.removeEventListener('transitionend', this.onSlideToWrapperTransitionEnd);
                        this.onSlideToWrapperTransitionEnd = null;
                        delete this.onSlideToWrapperTransitionEnd;
                        this.transitionEnd(runCallbacks, internal);
                    };
                }
                wrapper.addEventListener('transitionend', this.onSlideToWrapperTransitionEnd);
            }

            return this;
        }

        slideNext(speed = this.params.speed, runCallbacks = true, internal) {
            const {enabled, params, animating} = this;
            if (!enabled) return this;

            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                perGroup = Math.max(this.slidesPerViewDynamic('current', true), 1);
            }

            const increment = this.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            const isVirtual = this.virtual && params.virtual.enabled;

            if (params.loop) {
                if (animating && params.loopPreventsSliding) return false;
                this.loopFix();
                // eslint-disable-next-line
                this._clientLeft = this.wrapper.clientLeft;
            }
            if (params.rewind && this.isEnd) {
                return this.slideTo(0, speed, runCallbacks, internal);
            }
            return this.slideTo(this.activeIndex + increment, speed, runCallbacks, internal);
        }

        slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
            const {params, animating, snapGrid, slidesGrid, rtlTranslate, enabled} = this;
            if (!enabled) return this;

            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                perGroup = Math.max(this.slidesPerViewDynamic('current', true), 1);
                const moveSlides = this.activeIndex - perGroup;
                const activeSlides = this.activeIndex - moveSlides;
                perGroup = activeSlides;
            }

            if (params.loop) {
                if (animating && params.loopPreventsSliding) return false;
                this.loopFix();
                // eslint-disable-next-line
                this._clientLeft = this.wrapper.clientLeft;
            }

            const translate = rtlTranslate ? this.translate : -this.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map(val => normalize(val));
            
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

            if (typeof prevSnap === 'undefined' && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) {
                        // prevSnap = snap;
                        prevSnapIndex = snapIndex;
                    }
                });
                if (typeof prevSnapIndex !== 'undefined') {
                    prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
                }
            }

            let prevIndex = 0;
            if (typeof prevSnap !== 'undefined') {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = this.activeIndex - 1;
                if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - this.slidesPerViewDynamic('previous', true) + perGroup;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && this.isBeginning) {
                const lastIndex = this.params.virtual && this.params.virtual.enabled && this.virtual ? this.virtual.slides.length - 1 : this.slides.length - 1;
                return this.slideTo(lastIndex, speed, runCallbacks, internal);
            }
            return this.slideTo(prevIndex, speed, runCallbacks, internal);
        }

        // Events
        initEvents() {
            this.onTouchStart = this.onTouchStart.bind(this);
            this.onTouchMove = this.onTouchMove.bind(this);
            this.onTouchEnd = this.onTouchEnd.bind(this);
            this.onResize = this.onResize.bind(this);
            this.onClick = this.onClick.bind(this);
            this.onScroll = this.onScroll.bind(this);

            this.attachEvents();
        }

        attachEvents() {
            const {params} = this;
            const {
                el, wrapper, slides
            } = this;

            this.onTouchStartData = {};

            el.addEventListener('touchstart', this.onTouchStart, {passive: false});
            el.addEventListener('touchmove', this.onTouchMove, {passive: false});
            el.addEventListener('touchend', this.onTouchEnd, {passive: true});

            el.addEventListener('mousedown', this.onTouchStart, {passive: false});
            document.addEventListener('mousemove', this.onTouchMove, {passive: false});
            document.addEventListener('mouseup', this.onTouchEnd, {passive: true});

            el.addEventListener('pointerdown', this.onTouchStart, {passive: false});
            document.addEventListener('pointermove', this.onTouchMove, {passive: false});
            document.addEventListener('pointerup', this.onTouchEnd, {passive: true});

            if (params.cssMode) {
                wrapper.addEventListener('scroll', this.onScroll);
            }

            if (params.updateOnWindowResize) {
                window.addEventListener('resize', this.onResize);
            }

            el.addEventListener('click', this.onClick, true);
        }

        detachEvents() {
            const {
                el, wrapper
            } = this;

            el.removeEventListener('touchstart', this.onTouchStart);
            el.removeEventListener('touchmove', this.onTouchMove);
            el.removeEventListener('touchend', this.onTouchEnd);

            el.removeEventListener('mousedown', this.onTouchStart);
            document.removeEventListener('mousemove', this.onTouchMove);
            document.removeEventListener('mouseup', this.onTouchEnd);

            el.removeEventListener('pointerdown', this.onTouchStart);
            document.removeEventListener('pointermove', this.onTouchMove);
            document.removeEventListener('pointerup', this.onTouchEnd);

            if (this.params.cssMode) {
                wrapper.removeEventListener('scroll', this.onScroll);
            }

            window.removeEventListener('resize', this.onResize);
            el.removeEventListener('click', this.onClick, true);
        }

        onTouchStart(event) {
            const swiper = this;
            const {enabled, allowTouchMove, params} = swiper;
            if (!enabled) return;
            if (!allowTouchMove && swiper.animating) return;

            let e = event;
            if (e.originalEvent) e = e.originalEvent;

            const data = swiper.touchEventsData;

            if (e.type === 'pointerdown') {
                if (data.pointerId !== null && data.pointerId !== e.pointerId) {
                    return;
                }
                data.pointerId = e.pointerId;
            } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
                data.touchId = e.targetTouches[0].identifier;
            }

            if (e.type === 'touchstart') {
                // don't proceed touch event
                swiper.preventTouch(e);
                return;
            }

            const targetEl = e.target;

            if (params.touchEventsTarget === 'wrapper' && !swiper.wrapper.contains(targetEl)) return;
            if ('which' in e && e.which === 3) return;
            if ('button' in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;

            const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
            // eslint-disable-next-line
            const eventPath = event.composedPath ? event.composedPath() : event.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
                targetEl = eventPath[0];
            }

            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);

            // use closestElement for shadow root element to get the actual closest for nested shadow root element
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                swiper.allowClick = true;
                return;
            }

            if (params.swipeHandler) {
                if (!targetEl.closest(params.swipeHandler)) return;
            }

            swiper.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            swiper.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
            const startX = swiper.touches.currentX;
            const startY = swiper.touches.currentY;

            // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore
            const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
                if (edgeSwipeDetection === 'prevent') {
                    event.preventDefault();
                } else {
                    return;
                }
            }

            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: undefined,
                startMoving: undefined
            });

            swiper.touches.startX = startX;
            swiper.touches.startY = startY;
            data.touchStartTime = Date.now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = undefined;
            if (params.threshold > 0) data.allowThresholdMove = false;
            let preventDefault = true;
            if (targetEl.matches(params.focusableElements)) {
                preventDefault = false;
                if (targetEl.nodeName === 'SELECT') {
                    data.isTouched = false;
                }
            }
            if (document.activeElement && document.activeElement.matches(params.focusableElements) && document.activeElement !== targetEl) {
                document.activeElement.blur();
            }

            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
                e.preventDefault();
            }

            if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
                swiper.freeMode.onTouchStart();
            }

            swiper.emit('touchStart', e);
        }

        onTouchMove(event) {
            const document = getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            if (!swiper.allowTouchMove) {
                if (!event.target.matches(swiper.params.focusableElements)) {
                    swiper.allowClick = false;
                }
                if (data.isTouched) {
                    Object.assign(swiper.touches, {
                        startX: swiper.touches.currentX,
                        startY: swiper.touches.currentY,
                        currentX: swiper.touches.currentX,
                        currentY: swiper.touches.currentY
                    });
                    data.touchStartTime = Date.now();
                }
                return;
            }

            let e = event;
            if (e.originalEvent) e = e.originalEvent;

            if (e.type === 'pointermove') {
                if (data.touchId !== null) return; // return from pointer if we have touch event
                const id = e.pointerId;
                if (id !== data.pointerId) return;
            }

            let targetTouch;
            if (e.type === 'touchmove') {
                targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            } else {
                targetTouch = e;
            }

            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) {
                    swiper.emit('touchMoveOpposite', e);
                }
                return;
            }

            const pageX = targetTouch.pageX;
            const pageY = targetTouch.pageY;

            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && pageX - touches.startX > 0) {
                return;
            }
            if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && pageX - touches.startX < 0) {
                return;
            }

            if (!data.allowTouchCallbacks) {
                e.preventDefault();
                return;
            }

            if (params.touchReleaseOnEdges && !params.loop) {
                if (swiper.isVertical()) {
                    // Vertical
                    if ((pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())) {
                        data.isTouched = false;
                        data.isMoved = false;
                        return;
                    }
                } else if ((pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {
                    return;
                }
            }

            if (document.activeElement) {
                if (e.target === document.activeElement && e.target.matches(params.focusableElements)) {
                    data.isMoved = true;
                    swiper.allowClick = false;
                    return;
                }
            }

            if (data.allowTouchCallbacks) {
                swiper.emit('touchMove', e);
            }

            if (e.targetTouches && e.targetTouches.length > 1) return;

            touches.currentX = pageX;
            touches.currentY = pageY;

            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

            if (typeof data.isScrolling === 'undefined') {
                let touchAngle;
                if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
                    data.isScrolling = false;
                } else {
                    // eslint-disable-next-line
                    if (diffX * diffX + diffY * diffY >= 25) {
                        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
                    }
                }
            }

            if (data.isScrolling) {
                swiper.emit('touchMoveOpposite', e);
            }

            if (typeof data.startMoving === 'undefined') {
                if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
                    data.startMoving = true;
                }
            }

            if (data.isScrolling || (e.type === 'touchmove' && data.preventTouchMoveFromPointerMove)) {
                data.isTouched = false;
                return;
            }

            if (!data.startMoving) {
                return;
            }

            swiper.allowClick = false;

            if (!params.cssMode && e.cancelable) {
                e.preventDefault();
            }

            if (params.touchMoveStopPropagation && !params.nested) {
                e.stopPropagation();
            }

            if (!data.isMoved) {
                if (params.loop && !params.cssMode) {
                    swiper.loopFix();
                }

                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);

                if (swiper.animating) {
                    const evt = new window.CustomEvent('transitionend', {
                        bubbles: true,
                        cancelable: true
                    });
                    swiper.wrapper.dispatchEvent(evt);
                }

                data.allowMomentumBounce = false;
                // Grab Cursor
                if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                    swiper.setGrabCursor(true);
                }

                swiper.emit('sliderFirstMove', e);
            }

            swiper.emit('sliderMove', e);
            data.isMoved = true;

            let diff = swiper.isHorizontal() ? diffX : diffY;
            touches.diff = diff;

            diff *= params.touchRatio;
            if (rtl) diff = -diff;

            swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
            data.currentTranslate = diff + data.startTranslate;

            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;

            if (params.touchReleaseOnEdges) {
                resistanceRatio = 0;
            }

            if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
                disableParentSwiper = false;
                if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
            } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
                disableParentSwiper = false;
                if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
            }

            if (disableParentSwiper) {
                e.preventedByNestedSwiper = true;
            }

            // Directions locks
            if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
                data.currentTranslate = data.startTranslate;
            }

            if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
                data.currentTranslate = data.startTranslate;
            }

            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
                data.currentTranslate = data.startTranslate;
            }

            // Threshold
            if (params.threshold > 0) {
                if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                    if (!data.allowThresholdMove) {
                        data.allowThresholdMove = true;
                        touches.startX = touches.currentX;
                        touches.startY = touches.currentY;
                        data.currentTranslate = data.startTranslate;
                        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                        return;
                    }
                } else {
                    data.currentTranslate = data.startTranslate;
                    return;
                }
            }

            if (!params.followFinger || params.cssMode) return;

            // Update active index in free mode
            if ((params.freeMode && params.freeMode.enabled && swiper.freeMode) || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }

            if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
                swiper.freeMode.onTouchMove();
            }

            // Update progress
            swiper.updateProgress(data.currentTranslate);

            // Update translate
            swiper.setTranslate(data.currentTranslate);
        }

        onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;

            const {
                params, touches, rtlTranslate: rtl, slidesGrid, enabled
            } = swiper;

            if (!enabled) return;

            let e = event;
            if (e.originalEvent) e = e.originalEvent;

            if (e.type === 'touchend' || e.type === 'touchcancel') {
                const touch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
                if (!touch || touch.identifier !== data.touchId) return;
            } else if (data.touchId !== null) {
                return; // return from pointer if we have touch event
            } else if (e.pointerId !== data.pointerId) {
                return;
            }

            if (['pointercancel', 'pointerout', 'pointerleave'].indexOf(e.type) >= 0) {
                const proceed = ['pointercancel'].indexOf(e.type) >= 0 && (swiper.browser.isSafari || swiper.browser.isWebView);
                if (!proceed) {
                    return;
                }
            }

            data.pointerId = null;
            data.touchId = null;

            if (data.allowTouchCallbacks) {
                swiper.emit('touchEnd', e);
            }

            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) {
                    swiper.setGrabCursor(false);
                }
                data.isMoved = false;
                data.startMoving = false;
                return;
            }

            // Return Grab Cursor
            if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                swiper.setGrabCursor(false);
            }

            // Time diff
            const touchEndTime = Date.now();
            const timeDiff = touchEndTime - data.touchStartTime;

            // Tap, doubleTap, Click
            if (swiper.allowClick) {
                const pathTree = e.path || (e.composedPath && e.composedPath());
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
                swiper.emit('tap click', e);

                if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
                    swiper.emit('doubleTap doubleClick', e);
                }
            }

            data.lastClickTime = Date.now();

            nextTick(() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            });

            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }

            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;

            let currentPos;
            if (params.followFinger) {
                currentPos = rtl ? swiper.translate : -swiper.translate;
            } else {
                currentPos = -data.currentTranslate;
            }

            if (params.cssMode) {
                return;
            }

            if (swiper.params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }

            // Find current slide
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if (typeof slidesGrid[i + increment] !== 'undefined') {
                    if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }

            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) {
                if (swiper.isBeginning) {
                    rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                } else if (swiper.isEnd) {
                    rewindFirstIndex = 0;
                }
            }
            // Find current slide size
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

            if (timeDiff > params.longSwipesMs) {
                // Long touches
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (swiper.swipeDirection === 'next') {
                    if (ratio >= params.longSwipesRatio) {
                        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
                    } else {
                        swiper.slideTo(stopIndex);
                    }
                }

                if (swiper.swipeDirection === 'prev') {
                    if (ratio > (1 - params.longSwipesRatio)) {
                        swiper.slideTo(stopIndex + increment);
                    } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                        swiper.slideTo(rewindLastIndex);
                    } else {
                        swiper.slideTo(stopIndex);
                    }
                }
            } else {
                // Short swipes
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }

                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if (swiper.swipeDirection === 'next') {
                        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                    }

                    if (swiper.swipeDirection === 'prev') {
                        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                    }
                } else if (e.target === swiper.navigation.nextEl) {
                    swiper.slideTo(stopIndex + increment);
                } else {
                    swiper.slideTo(stopIndex);
                }
            }
        }

        onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }

        onResize() {
            const swiper = this;
            const {initialized, params} = swiper;
            if (initialized && params.breakpoints) {
                swiper.setBreakpoint();
            }

            // Save locks
            const {allowSlideNext, allowSlidePrev} = swiper;

            // Disable locks on resize
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;

            swiper.updateSize();
            swiper.updateSlides();

            swiper.updateSlidesClasses();
            if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
                swiper.slideTo(swiper.slides.length - 1, 0, false, true);
            } else {
                swiper.slideTo(swiper.activeIndex, 0, false, true);
            }

            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                swiper.autoplay.run();
            }
            // Return locks after resize
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;

            if (swiper.params.watchOverflow && swiper.enabled) {
                swiper.checkOverflow();
            }
        }

        onScroll() {
            const swiper = this;
            if (swiper.animating) {
                swiper.setTransition(0);
            }
        }

        // Helpers
        isHorizontal() {
            return this.params.direction === 'horizontal';
        }

        isVertical() {
            return this.params.direction === 'vertical';
        }

        getDirectionLabel(property) {
            if (this.isHorizontal()) {
                return property;
            }
            // prettier-ignore
            return {
                'width': 'height',
                'margin-top': 'margin-left',
                'margin-bottom ': 'margin-right',
                'margin-left': 'margin-top',
                'margin-right': 'margin-bottom',
                'padding-left': 'padding-top',
                'padding-right': 'padding-bottom',
                'marginRight': 'marginBottom'
            }[property];
        }

        getSlideProgress(el) {
            const swiper = this;
            const {size} = swiper;
            const slideOffset = swiper.getSlideOffset(el);
            const offsetCenter = -swiper.translate;
            const progress = (offsetCenter - slideOffset) / size;
            return progress;
        }

        getSlideOffset(el) {
            return this.rtlTranslate ? -el.swiperSlideOffset : el.swiperSlideOffset;
        }

        getSlideTranslate(el) {
            const swiper = this;
            const {rtlTranslate, size} = swiper;
            const slideOffset = swiper.getSlideOffset(el);
            const progress = swiper.getSlideProgress(el);
            let translate = slideOffset + progress * size;
            if (rtlTranslate) translate = -translate;
            return translate;
        }

        // Transition
        transitionStart(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;

            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }

            let {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) {
                if (activeIndex > previousIndex) dir = 'next';
                else if (activeIndex < previousIndex) dir = 'prev';
                else dir = 'reset';
            }

            swiper.emit('transitionStart');

            if (runCallbacks && activeIndex !== previousIndex) {
                if (dir === 'reset') {
                    swiper.emit('slideResetTransitionStart');
                    return;
                }
                swiper.emit('slideChangeTransitionStart');
                if (dir === 'next') {
                    swiper.emit('slideNextTransitionStart');
                } else {
                    swiper.emit('slidePrevTransitionStart');
                }
            }
        }

        transitionEnd(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;

            swiper.setTransition(0);

            let {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) {
                if (activeIndex > previousIndex) dir = 'next';
                else if (activeIndex < previousIndex) dir = 'prev';
                else dir = 'reset';
            }

            swiper.emit('transitionEnd');

            if (runCallbacks && activeIndex !== previousIndex) {
                if (dir === 'reset') {
                    swiper.emit('slideResetTransitionEnd');
                    return;
                }
                swiper.emit('slideChangeTransitionEnd');
                if (dir === 'next') {
                    swiper.emit('slideNextTransitionEnd');
                } else {
                    swiper.emit('slidePrevTransitionEnd');
                }
            }
        }

        // Navigation
        initNavigation() {
            const swiper = this;
            const {params} = swiper;

            if (!params.navigation || (!params.navigation.nextEl && !params.navigation.prevEl)) return;

            swiper.navigation = {
                nextEl: null,
                prevEl: null,
                ...swiper.navigation
            };

            const {nextEl: nextElParam, prevEl: prevElParam} = params.navigation;

            if (nextElParam) {
                swiper.navigation.nextEl = getElement(nextElParam);
                if (swiper.navigation.nextEl) {
                    swiper.navigation.nextEl.addEventListener('click', swiper.onNextClick.bind(swiper));
                }
            }
            if (prevElParam) {
                swiper.navigation.prevEl = getElement(prevElParam);
                if (swiper.navigation.prevEl) {
                    swiper.navigation.prevEl.addEventListener('click', swiper.onPrevClick.bind(swiper));
                }
            }

            swiper.updateNavigation();
        }

        destroyNavigation() {
            const swiper = this;
            const {navigation} = swiper;
            if (navigation.nextEl) {
                navigation.nextEl.removeEventListener('click', swiper.onNextClick);
            }
            if (navigation.prevEl) {
                navigation.prevEl.removeEventListener('click', swiper.onPrevClick);
            }
        }

        onPrevClick(e) {
            e.preventDefault();
            if (this.isBeginning && !this.params.loop && !this.params.rewind) return;
            this.slidePrev();
            this.emit('navigationPrev');
        }

        onNextClick(e) {
            e.preventDefault();
            if (this.isEnd && !this.params.loop && !this.params.rewind) return;
            this.slideNext();
            this.emit('navigationNext');
        }

        updateNavigation() {
            const swiper = this;
            const {navigation} = swiper;

            if (!navigation.nextEl && !navigation.prevEl) return;

            const isBeginning = swiper.isBeginning;
            const isEnd = swiper.isEnd;

            if (navigation.prevEl) {
                if (isBeginning && !swiper.params.loop && !swiper.params.rewind) {
                    navigation.prevEl.classList.add(swiper.params.navigation.disabledClass);
                } else {
                    navigation.prevEl.classList.remove(swiper.params.navigation.disabledClass);
                }
            }

            if (navigation.nextEl) {
                if (isEnd && !swiper.params.loop && !swiper.params.rewind) {
                    navigation.nextEl.classList.add(swiper.params.navigation.disabledClass);
                } else {
                    navigation.nextEl.classList.remove(swiper.params.navigation.disabledClass);
                }
            }
        }

        // Pagination
        initPagination() {
            const swiper = this;
            const {params} = swiper;

            if (!params.pagination || !params.pagination.el) return;

            swiper.pagination = {
                el: null,
                bullets: [],
                ...swiper.pagination
            };

            swiper.pagination.el = getElement(params.pagination.el);
            if (!swiper.pagination.el) return;

            if (params.pagination.type === 'bullets') {
                swiper.pagination.render();
                swiper.pagination.update();
            }
        }

        destroyPagination() {
            const swiper = this;
            const {pagination} = swiper;

            if (pagination.bullets) {
                pagination.bullets.forEach(bulletEl => {
                    bulletEl.removeEventListener('click', swiper.onBulletClick);
                });
            }
        }

        renderPagination() {
            const swiper = this;
            const {pagination, params} = swiper;
            const slidesLength = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

            let paginationHTML = '';
            if (params.pagination.type === 'bullets') {
                let numberOfBullets = params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / params.slidesPerGroup) : swiper.snapGrid.length;
                if (params.freeMode && params.freeMode.enabled && !params.loop && numberOfBullets > slidesLength) {
                    numberOfBullets = slidesLength;
                }
                for (let i = 0; i < numberOfBullets; i += 1) {
                    if (params.pagination.renderBullet) {
                        paginationHTML += params.pagination.renderBullet.call(swiper, i, params.pagination.bulletClass);
                    } else {
                        paginationHTML += `<${params.pagination.bulletElement} class="${params.pagination.bulletClass}"></${params.pagination.bulletElement}>`;
                    }
                }
            }
            pagination.el.innerHTML = paginationHTML;

            pagination.bullets = [...pagination.el.querySelectorAll(`.${params.pagination.bulletClass.replace(/ /g, '.')}`)];
        }

        updatePagination() {
            const swiper = this;
            const {pagination, params} = swiper;

            if (!pagination.el || !pagination.bullets || pagination.bullets.length === 0) return;

            // Handle bullets
            if (params.pagination.type === 'bullets') {
                pagination.bullets.forEach((bulletEl, bulletIndex) => {
                    if (params.pagination.clickable) {
                        bulletEl.classList.add(params.pagination.clickableClass);
                        bulletEl.addEventListener('click', swiper.onBulletClick.bind(swiper));
                    }
                    bulletEl.classList.remove(params.pagination.bulletActiveClass);
                });

                if (pagination.bullets[swiper.realIndex]) {
                    pagination.bullets[swiper.realIndex].classList.add(params.pagination.bulletActiveClass);
                }
            }
        }

        onBulletClick(e) {
            const swiper = this;
            const bulletEl = e.target;
            const index = [...bulletEl.parentElement.children].indexOf(bulletEl);
            swiper.slideTo(index);
        }

        // Scrollbar
        initScrollbar() {
            // Basic scrollbar implementation would go here
        }

        // Autoplay
        initAutoplay() {
            const swiper = this;
            const {params} = swiper;

            if (!params.autoplay || !params.autoplay.enabled) return;

            swiper.autoplay = {
                running: false,
                paused: false,
                timeLeft: 0,
                timeout: null,
                ...swiper.autoplay
            };

            swiper.autoplay.start = function() {
                if (swiper.autoplay.running) return false;
                swiper.autoplay.running = true;
                swiper.emit('autoplayStart');
                swiper.autoplay.run();
                return true;
            };

            swiper.autoplay.pause = function(speed) {
                if (!swiper.autoplay.running) return;
                if (swiper.autoplay.paused) return;
                if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
                swiper.autoplay.paused = true;
                if (speed === 0 || !params.autoplay.waitForTransition) {
                    swiper.autoplay.paused = false;
                    swiper.autoplay.run();
                } else {
                    ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                        swiper.wrapper.addEventListener(event, swiper.autoplay.onTransitionEnd);
                    });
                }
            };

            swiper.autoplay.run = function() {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (swiper.autoplay.paused) return;
                swiper.autoplay.timeout = setTimeout(() => {
                    if (params.autoplay.reverseDirection) {
                        if (params.loop) {
                            swiper.loopFix();
                            swiper.slidePrev(params.speed, true, true);
                            swiper.emit('autoplay');
                        } else if (!swiper.isBeginning) {
                            swiper.slidePrev(params.speed, true, true);
                            swiper.emit('autoplay');
                        } else if (params.autoplay.stopOnLastSlide) {
                            swiper.autoplay.stop();
                            return;
                        } else {
                            swiper.slideTo(swiper.slides.length - 1, params.speed, true, true);
                            swiper.emit('autoplay');
                        }
                    } else if (params.loop) {
                        swiper.loopFix();
                        swiper.slideNext(params.speed, true, true);
                        swiper.emit('autoplay');
                    } else if (!swiper.isEnd) {
                        swiper.slideNext(params.speed, true, true);
                        swiper.emit('autoplay');
                    } else if (params.autoplay.stopOnLastSlide) {
                        swiper.autoplay.stop();
                        return;
                    } else {
                        swiper.slideTo(0, params.speed, true, true);
                        swiper.emit('autoplay');
                    }
                    if (params.cssMode && swiper.animating) {
                        swiper.autoplay.run();
                    } else {
                        swiper.autoplay.run();
                    }
                }, swiper.autoplay.delay || params.autoplay.delay || 3000);
            };

            swiper.autoplay.stop = function() {
                if (!swiper.autoplay.running) return false;
                if (swiper.autoplay.timeout) {
                    clearTimeout(swiper.autoplay.timeout);
                }
                swiper.autoplay.running = false;
                swiper.emit('autoplayStop');
                return true;
            };

            swiper.autoplay.onTransitionEnd = function() {
                if (!swiper || swiper.destroyed || !swiper.wrapper) return;
                swiper.wrapper.removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
                swiper.wrapper.removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
                swiper.autoplay.paused = false;
                if (!swiper.autoplay.running) {
                    swiper.autoplay.stop();
                } else {
                    swiper.autoplay.run();
                }
            };

            if (params.autoplay.enabled) {
                swiper.autoplay.start();
            }
        }

        // Lazy loading
        initLazy() {
            // Basic lazy loading implementation would go here
        }

        // Breakpoints
        initBreakpoints() {
            const swiper = this;
            const {params} = swiper;

            if (!params.breakpoints) return;

            swiper.currentBreakpoint = swiper.getBreakpoint(params.breakpoints, swiper.base, swiper.container);
            if (swiper.currentBreakpoint) {
                swiper.setBreakpoint();
            }
        }

        getBreakpoint(breakpoints, base, containerEl) {
            const window = getWindow();
            const breakpoint = Object.keys(breakpoints).map(point => {
                if (typeof point === 'string' && point.indexOf('@') === 0) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = window.innerHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            });
            breakpoint.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
            for (let i = 0; i < breakpoint.length; i += 1) {
                const {point, value} = breakpoint[i];
                if (value <= window.innerWidth) {
                    return point;
                }
            }
            return 'max';
        }

        setBreakpoint() {
            const swiper = this;
            const {activeIndex, initialized, loopedSlides = 0, params, $el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;

            // Get breakpoint for window width and update parameters
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.base, swiper.container);
            const breakpointOnlyParams = swiper.parameters && swiper.parameters[breakpoint];

            if (!breakpoint || !breakpointOnlyParams) return;

            const wasMultiRow = swiper.grid && params.grid && params.grid.rows > 1;
            const wasEnabled = params.enabled;

            if (wasMultiRow) {
                breakpointOnlyParams.grid = breakpointOnlyParams.grid || {};
                breakpointOnlyParams.grid.rows = breakpointOnlyParams.grid.rows || 1;
            }

            const wasLoop = params.loop;
            const wasPerView = params.slidesPerView;

            // Extend parameters
            extend(params, breakpointOnlyParams || {});

            const isEnabled = params.enabled;
            const hasLoop = params.loop;
            const needsReLoop = wasPerView !== params.slidesPerView;

            if (wasEnabled && !isEnabled) {
                swiper.disable();
            } else if (!wasEnabled && isEnabled) {
                swiper.enable();
            }

            swiper.currentBreakpoint = breakpoint;
            swiper.emit('breakpoint', breakpointOnlyParams);

            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate();
                swiper.updateSlides();
                swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
            }

            if (hasLoop && !wasLoop) {
                swiper.loopCreate();
                swiper.updateSlides();
                swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
            } else if (!hasLoop && wasLoop) {
                swiper.loopDestroy();
                swiper.updateSlides();
                swiper.slideTo(activeIndex - loopedSlides, 0, false);
            }
        }

        // Loop
        loopCreate() {
            const swiper = this;
            const document = getDocument();
            const {params, slides} = swiper;

            if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled)) return;

            swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
            swiper.loopedSlides += params.loopAdditionalSlides;
            if (swiper.loopedSlides > slides.length && params.loopedSlidesLimit) {
                swiper.loopedSlides = slides.length;
            }

            const prependSlides = [];
            const appendSlides = [];
            slides.forEach((el, index) => {
                if (index < swiper.loopedSlides) {
                    appendSlides.push(el);
                }
                if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
                    prependSlides.push(el);
                }
                el.setAttribute('data-swiper-slide-index', index);
            });

            for (let i = 0; i < appendSlides.length; i += 1) {
                const slideEl = appendSlides[i].cloneNode(true);
                slideEl.classList.add(params.slideDuplicateClass);
                swiper.wrapper.append(slideEl);
            }
            for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
                const slideEl = prependSlides[i].cloneNode(true);
                slideEl.classList.add(params.slideDuplicateClass);
                swiper.wrapper.prepend(slideEl);
            }
        }

        loopFix() {
            const swiper = this;
            swiper.emit('beforeLoopFix');
            const {activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl} = swiper;
            let newIndex;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;

            const snapTranslate = -snapGrid[activeIndex];
            const diff = snapTranslate - swiper.getTranslate();

            // Fix For Negative Oversliding
            if (activeIndex < loopedSlides) {
                newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
                newIndex += loopedSlides;
                const slideChanged = swiper.slideTo(newIndex, 0, false, true);
                if (slideChanged && diff !== 0) {
                    swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
                }
            } else if (activeIndex >= slides.length - loopedSlides) {
                // Fix For Positive Oversliding
                newIndex = -slides.length + activeIndex + loopedSlides;
                newIndex += loopedSlides;
                const slideChanged = swiper.slideTo(newIndex, 0, false, true);
                if (slideChanged && diff !== 0) {
                    swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
                }
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            swiper.emit('loopFix');
        }

        loopDestroy() {
            const swiper = this;
            const {wrapper, params} = swiper;
            wrapper.children.forEach(slideEl => {
                if (slideEl.classList.contains(params.slideDuplicateClass)) {
                    slideEl.remove();
                }
            });
            swiper.loopedSlides = null;
        }

        // Events
        emit(...args) {
            const swiper = this;
            if (!swiper.eventsListeners) return swiper;
            let events;
            let data;
            let context;
            if (typeof args[0] === 'string' || Array.isArray(args[0])) {
                events = args[0];
                data = args.slice(1, args.length);
                context = swiper;
            } else {
                events = args[0].events;
                data = args[0].data;
                context = args[0].context || swiper;
            }
            data.unshift(context);
            const eventsArray = Array.isArray(events) ? events : events.split(' ');
            eventsArray.forEach(event => {
                if (swiper.eventsListeners && swiper.eventsListeners[event]) {
                    swiper.eventsListeners[event].forEach(eventHandler => {
                        eventHandler.apply(context, data);
                    });
                }
            });
            return swiper;
        }

        on(events, handler, priority) {
            const swiper = this;
            if (!swiper.eventsListeners) swiper.eventsListeners = {};
            if (typeof handler !== 'function') return swiper;
            const method = priority ? 'unshift' : 'push';
            events.split(' ').forEach(event => {
                if (!swiper.eventsListeners[event]) swiper.eventsListeners[event] = [];
                swiper.eventsListeners[event][method](handler);
            });
            return swiper;
        }

        once(events, handler, priority) {
            const swiper = this;
            if (typeof handler !== 'function') return swiper;
            function onceHandler(...args) {
                swiper.off(events, onceHandler);
                if (onceHandler.__emitterProxy) {
                    delete onceHandler.__emitterProxy;
                }
                handler.apply(swiper, args);
            }
            onceHandler.__emitterProxy = handler;
            return swiper.on(events, onceHandler, priority);
        }

        onAny(handler, priority) {
            const swiper = this;
            if (typeof handler !== 'function') return swiper;
            const method = priority ? 'unshift' : 'push';
            if (swiper.eventsAnyListeners.indexOf(handler) < 0) {
                swiper.eventsAnyListeners[method](handler);
            }
            return swiper;
        }

        offAny(handler) {
            const swiper = this;
            if (!swiper.eventsAnyListeners) return swiper;
            const index = swiper.eventsAnyListeners.indexOf(handler);
            if (index >= 0) {
                swiper.eventsAnyListeners.splice(index, 1);
            }
            return swiper;
        }

        off(events, handler) {
            const swiper = this;
            if (!swiper.eventsListeners) return swiper;
            events.split(' ').forEach(event => {
                if (typeof handler === 'undefined') {
                    swiper.eventsListeners[event] = [];
                } else if (swiper.eventsListeners[event]) {
                    swiper.eventsListeners[event].forEach((eventHandler, index) => {
                        if (eventHandler === handler || (eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler)) {
                            swiper.eventsListeners[event].splice(index, 1);
                        }
                    });
                }
            });
            return swiper;
        }

        // Utils
        checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;

            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                swiper.isLocked = lastSlideRightEdge <= swiper.size;
            } else {
                swiper.isLocked = swiper.snapGrid.length === 1;
            }

            if (params.allowSlideNext === true) {
                swiper.allowSlideNext = !swiper.isLocked;
            }
            if (params.allowSlidePrev === true) {
                swiper.allowSlidePrev = !swiper.isLocked;
            }

            if (wasLocked && wasLocked !== swiper.isLocked) {
                swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
            }

            if (wasLocked !== swiper.isLocked) {
                swiper.updateSlidesClasses();
            }
        }

        updateClickedSlide(el) {
            const swiper = this;
            const clickedSlide = el.closest(`.${swiper.params.slideClass}`);
            let slideFound = false;
            let slideIndex;
            if (clickedSlide) {
                for (let i = 0; i < swiper.slides.length; i += 1) {
                    if (swiper.slides[i] === clickedSlide) {
                        slideFound = true;
                        slideIndex = i;
                        break;
                    }
                }
            }
            if (clickedSlide && slideFound) {
                swiper.clickedSlide = clickedSlide;
                if (swiper.virtual && swiper.params.virtual.enabled) {
                    swiper.clickedIndex = parseInt(clickedSlide.getAttribute('data-swiper-slide-index'), 10);
                } else {
                    swiper.clickedIndex = slideIndex;
                }
            } else {
                swiper.clickedSlide = undefined;
                swiper.clickedIndex = undefined;
                return;
            }
            if (swiper.params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
                swiper.slideTo(swiper.clickedIndex);
            }
        }

        setGrabCursor(grab) {
            const swiper = this;
            if (swiper.support.touch || (!swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) || swiper.params.cssMode) return;
            const el = swiper.params.touchEventsTarget === 'container' ? swiper.container : swiper.wrapper;
            el.style.cursor = grab ? 'grab' : 'default';
        }

        unsetGrabCursor() {
            const swiper = this;
            const el = swiper.params.touchEventsTarget === 'container' ? swiper.container : swiper.wrapper;
            el.style.cursor = '';
        }

        enable() {
            const swiper = this;
            if (swiper.enabled) return;
            swiper.enabled = true;
            if (swiper.params.grabCursor) {
                swiper.setGrabCursor();
            }
        }

        disable() {
            const swiper = this;
            if (!swiper.enabled) return;
            swiper.enabled = false;
            if (swiper.params.grabCursor) {
                swiper.unsetGrabCursor();
            }
        }

        // Support detection
        getSupport() {
            const window = getWindow();
            const document = getDocument();
            return {
                smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
                touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
                passiveListener: (function checkPassiveListener() {
                    let supportsPassive = false;
                    try {
                        const opts = Object.defineProperty({}, 'passive', {
                            // eslint-disable-next-line
                            get() {
                                supportsPassive = true;
                            }
                        });
                        window.addEventListener('testPassiveListener', null, opts);
                    } catch (e) {
                        // No support
                    }
                    return supportsPassive;
                })(),
                gestures: (function checkGestures() {
                    return 'ongesturestart' in window;
                })()
            };
        }

        getBrowser() {
            const window = getWindow();
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
            }
            return {
                isSafari: isSafari(),
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
            };
        }

        getDevice(overrides = {}) {
            const window = getWindow();
            return {
                ios: device.ios,
                android: device.android,
                androidChrome: device.android && window.navigator.userAgent.toLowerCase().indexOf('chrome') >= 0,
                desktop: !device.ios && !device.android,
                iphone: device.ios && !device.ipad,
                ipod: device.ios && device.ipod,
                ipad: device.ios && device.ipad,
                edge: window.navigator.userAgent.indexOf('Edge') >= 0,
                ie: window.MSInputMethodContext && window.documentMode,
                firefox: window.navigator.userAgent.toLowerCase().indexOf('firefox') >= 0,
                macos: device.macos,
                windows: device.windows,
                cordova: !!(window.cordova || window.phonegap),
                phonegap: !!(window.cordova || window.phonegap),
                electron: window.process && window.process.type,
                ...overrides
            };
        }

        // Touch Events Data
        get touchEventsData() {
            return this.onTouchStartData;
        }

        // Property getters
        get activeIndex() {
            return this._activeIndex || 0;
        }

        set activeIndex(index) {
            this._activeIndex = index;
        }

        get realIndex() {
            return this._realIndex || 0;
        }

        set realIndex(index) {
            this._realIndex = index;
        }

        get previousIndex() {
            return this._previousIndex || 0;
        }

        set previousIndex(index) {
            this._previousIndex = index;
        }

        get snapIndex() {
            return this._snapIndex || 0;
        }

        set snapIndex(index) {
            this._snapIndex = index;
        }

        get isBeginning() {
            return this._isBeginning !== undefined ? this._isBeginning : true;
        }

        set isBeginning(value) {
            this._isBeginning = value;
        }

        get isEnd() {
            return this._isEnd !== undefined ? this._isEnd : false;
        }

        set isEnd(value) {
            this._isEnd = value;
        }

        // Destroy
        destroy(deleteInstance = true, cleanStyles = true) {
            const swiper = this;
            const {container, slides, wrapper, params} = swiper;

            if (typeof swiper.params === 'undefined' || swiper.destroyed) {
                return null;
            }

            swiper.emit('beforeDestroy');

            // Destroy loop
            if (params.loop) {
                swiper.loopDestroy();
            }

            // Cleanup styles
            if (cleanStyles) {
                swiper.removeClasses();
                if (wrapper) wrapper.removeAttribute('style');
                if (container) container.removeAttribute('style');
                if (slides && slides.length) {
                    slides.forEach(slideEl => {
                        slideEl.classList.remove(
                            params.slideVisibleClass,
                            params.slideActiveClass,
                            params.slideNextClass,
                            params.slidePrevClass
                        );
                        slideEl.removeAttribute('style');
                        slideEl.removeAttribute('data-swiper-slide-index');
                    });
                }
            }

            swiper.emit('destroy');

            // Detach events
            Object.keys(swiper.eventsListeners).forEach(eventName => {
                swiper.off(eventName);
            });

            if (deleteInstance !== false) {
                swiper.container.swiper = null;
                deleteProps(swiper);
            }

            swiper.destroyed = true;

            return null;
        }

        removeClasses() {
            const swiper = this;
            const {container, slides, wrapper, params} = swiper;

            container.classList.remove(
                params.containerModifierClass + params.direction,
                params.containerModifierClass + 'free-mode',
                params.containerModifierClass + 'autoheight',
                params.containerModifierClass + 'watch-progress',
                params.containerModifierClass + 'centered',
                params.containerModifierClass + 'css-mode'
            );

            if (slides && slides.length) {
                slides.forEach(slideEl => {
                    slideEl.classList.remove(
                        params.slideClass,
                        params.slideActiveClass,
                        params.slideVisibleClass,
                        params.slideNextClass,
                        params.slidePrevClass,
                        params.slideDuplicateClass
                    );
                });
            }
        }

        // Static methods
        static use(modules) {
            const activeModules = Array.isArray(modules) ? modules : [modules];
            activeModules.forEach(module => {
                if (module.fn) {
                    Swiper.fn = {...Swiper.fn, ...module.fn};
                }
                if (module.install) {
                    module.install(Swiper);
                }
            });
            return Swiper;
        }

        static get(containerEl) {
            const container = getElement(containerEl);
            if (!container) return undefined;
            return container.swiper;
        }

        static defaults = {};
    }

    // Device detection
    const device = (function Device() {
        const platform = (getWindow().navigator && getWindow().navigator.platform) || '';
        const ua = (getWindow().navigator && getWindow().navigator.userAgent) || '';

        const device = {
            ios: false,
            android: false,
            androidChrome: false,
            desktop: false,
            iphone: false,
            ipod: false,
            ipad: false,
            edge: false,
            ie: false,
            firefox: false,
            macos: false,
            windows: false,
            cordova: false,
            phonegap: false,
            electron: false
        };

        const screenWidth = getWindow().screen.width;
        const screenHeight = getWindow().screen.height;

        const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
        const ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        const ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
        const edge = ua.indexOf('Edge/') >= 0;
        const firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
        const windows = platform === 'Win32';
        const electron = ua.toLowerCase().indexOf('electron') >= 0;
        let macos = platform === 'MacIntel';

        // iPadOs 13 fix
        const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
        if (!ipad && macos && getWindow().navigator.maxTouchPoints && getWindow().navigator.maxTouchPoints > 2 && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
            device.ipad = true;
            device.ios = true;
            macos = false;
        }

        device.ios = ipad || iphone || ipod;
        device.android = !!android && !device.ios;
        device.iphone = iphone && !ipad;
        device.ipod = ipod;
        device.ipad = ipad;
        device.edge = edge;
        device.ie = ie;
        device.firefox = firefox;
        device.macos = macos;
        device.windows = windows;
        device.cordova = !!(getWindow().cordova || getWindow().phonegap);
        device.phonegap = !!(getWindow().cordova || getWindow().phonegap);
        device.electron = electron;

        return device;
    })();

    // Browser detection
    const browser = (function Browser() {
        const window = getWindow();
        function isSafari() {
            const ua = window.navigator.userAgent.toLowerCase();
            return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
        }
        if (isSafari()) {
            const ua = String(window.navigator.userAgent);
            if (ua.includes('Version/')) {
                const version = ua.split('Version/')[1].split(' ')[0];
                return {
                    isSafari: true,
                    safariVersion: parseInt(version, 10)
                };
            }
            return {
                isSafari: true
            };
        }
        return {
            isSafari: false
        };
    })();

    // Support detection
    const support = (function Support() {
        const window = getWindow();
        const document = getDocument();
        return {
            smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
            touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
        };
    })();

    // Window and Document
    function getWindow() {
        return typeof window !== 'undefined' ? window : {};
    }

    function getDocument() {
        return typeof document !== 'undefined' ? document : {};
    }

    // Default parameters for different modules
    const defaultParams = {
        // Basic
        init: true,
        direction: 'horizontal',
        touchEventsTarget: 'wrapper',
        initialSlide: 0,
        speed: 300,
        cssMode: false,
        updateOnWindowResize: true,
        resizeObserver: true,
        nested: false,
        createElements: false,
        enabled: true,
        focusableElements: 'input, select, option, textarea, button, video, label',

        // Slides grid
        width: null,
        height: null,
        preventInteractionOnTransition: false,

        // Slides
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: false,
        centeredSlides: false,
        centeredSlidesBounds: false,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: true,
        centerInsufficientSlides: false,

        // Disable
        watchOverflow: true,

        // Round length
        roundLengths: false,

        // Touches
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 5,
        touchMoveStopPropagation: false,
        touchStartPreventDefault: true,
        touchStartForcePreventDefault: false,
        touchReleaseOnEdges: false,

        // Unique Navigation Elements
        uniqueNavElements: true,

        // Resistance
        resistance: true,
        resistanceRatio: 0.85,

        // Progress
        watchSlidesProgress: false,

        // Cursor
        grabCursor: false,

        // Clicks
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,

        // Images
        preloadImages: true,
        updateOnImagesReady: true,

        // loop
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopPreventsSliding: true,

        // rewind
        rewind: false,

        // Swiping/no swiping
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null,
        noSwiping: true,
        noSwipingClass: 'swiper-no-swiping',
        noSwipingSelector: null,

        // Passive Listeners
        passiveListeners: true,
        maxBackfaceHiddenSlides: 10,

        // NS
        containerModifierClass: 'swiper-',
        slideClass: 'swiper-slide',
        slideActiveClass: 'swiper-slide-active',
        slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
        slideVisibleClass: 'swiper-slide-visible',
        slideDuplicateClass: 'swiper-slide-duplicate',
        slideNextClass: 'swiper-slide-next',
        slideDuplicateNextClass: 'swiper-slide-duplicate-next',
        slidePrevClass: 'swiper-slide-prev',
        slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
        wrapperClass: 'swiper-wrapper',
        lazyPreloaderClass: 'swiper-lazy-preloader',
        lazyPreloadPrevNext: 0,

        // Callbacks
        runCallbacksOnInit: true,

        // Internals
        _emitClasses: false,

        // Navigation
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: false,
            disabledClass: 'swiper-button-disabled',
            hiddenClass: 'swiper-button-hidden',
            lockClass: 'swiper-button-lock',
            navigationDisabledClass: 'swiper-navigation-disabled'
        },

        // Pagination
        pagination: {
            el: null,
            bulletElement: 'span',
            clickable: false,
            hideOnClick: false,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: false,
            type: 'bullets',
            dynamicBullets: false,
            dynamicMainBullets: 1,
            formatFractionCurrent: number => number,
            formatFractionTotal: number => number,
            bulletClass: 'swiper-pagination-bullet',
            bulletActiveClass: 'swiper-pagination-bullet-active',
            modifierClass: 'swiper-pagination-',
            currentClass: 'swiper-pagination-current',
            totalClass: 'swiper-pagination-total',
            hiddenClass: 'swiper-pagination-hidden',
            progressbarFillClass: 'swiper-pagination-progressbar-fill',
            progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
            clickableClass: 'swiper-pagination-clickable',
            lockClass: 'swiper-pagination-lock',
            horizontalClass: 'swiper-pagination-horizontal',
            verticalClass: 'swiper-pagination-vertical',
            paginationDisabledClass: 'swiper-pagination-disabled'
        },

        // Scrollbar
        scrollbar: {
            el: null,
            dragSize: 'auto',
            hide: false,
            draggable: false,
            snapOnRelease: true,
            lockClass: 'swiper-scrollbar-lock',
            dragClass: 'swiper-scrollbar-drag',
            scrollbarDisabledClass: 'swiper-scrollbar-disabled',
            horizontalClass: 'swiper-horizontal',
            verticalClass: 'swiper-vertical'
        },

        // Autoplay
        autoplay: {
            enabled: false,
            delay: 3000,
            waitForTransition: true,
            disableOnInteraction: true,
            stopOnLastSlide: false,
            reverseDirection: false,
            pauseOnMouseEnter: false
        }
    };

    // Extend default parameters
    Object.assign(Swiper.defaults, defaultParams);

    // Initialize CSS
    const swiperCSS = `
        .swiper {
            margin-left: auto;
            margin-right: auto;
            position: relative;
            overflow: hidden;
            list-style: none;
            padding: 0;
            z-index: 1;
        }

        .swiper-vertical > .swiper-wrapper {
            flex-direction: column;
        }

        .swiper-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: flex;
            transition-property: transform;
            box-sizing: content-box;
        }

        .swiper-android .swiper-slide,
        .swiper-wrapper {
            transform: translate3d(0px, 0, 0);
        }

        .swiper-pointer-events {
            touch-action: pan-y;
        }

        .swiper-pointer-events.swiper-vertical {
            touch-action: pan-x;
        }

        .swiper-slide {
            flex-shrink: 0;
            width: 100%;
            height: 100%;
            position: relative;
            transition-property: transform;
        }

        .swiper-slide-invisible-blank {
            visibility: hidden;
        }

        .swiper-autoheight,
        .swiper-autoheight .swiper-slide {
            height: auto;
        }

        .swiper-autoheight .swiper-wrapper {
            align-items: flex-start;
            transition-property: transform, height;
        }

        .swiper-backface-hidden .swiper-slide {
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* Navigation */
        .swiper-button-next,
        .swiper-button-prev {
            position: absolute;
            top: 50%;
            width: calc(var(--swiper-navigation-size) / 44 * 27);
            height: var(--swiper-navigation-size);
            margin-top: calc(0px - (var(--swiper-navigation-size) / 2));
            z-index: 10;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--swiper-navigation-color, var(--swiper-theme-color));
        }

        .swiper-button-next.swiper-button-disabled,
        .swiper-button-prev.swiper-button-disabled {
            opacity: 0.35;
            cursor: auto;
            pointer-events: none;
        }

        .swiper-button-next.swiper-button-hidden,
        .swiper-button-prev.swiper-button-hidden {
            opacity: 0;
            cursor: auto;
            pointer-events: none;
        }

        .swiper-navigation-disabled .swiper-button-next,
        .swiper-navigation-disabled .swiper-button-prev {
            display: none !important;
        }

        .swiper-button-next:after,
        .swiper-button-prev:after {
            font-family: swiper-icons;
            font-size: var(--swiper-navigation-size);
            text-transform: none !important;
            letter-spacing: 0;
            font-variant: initial;
            line-height: 1;
        }

        .swiper-button-prev,
        .swiper-rtl .swiper-button-next {
            left: 10px;
            right: auto;
        }

        .swiper-button-prev:after,
        .swiper-rtl .swiper-button-next:after {
            content: 'prev';
        }

        .swiper-button-next,
        .swiper-rtl .swiper-button-prev {
            right: 10px;
            left: auto;
        }

        .swiper-button-next:after,
        .swiper-rtl .swiper-button-prev:after {
            content: 'next';
        }

        .swiper-button-lock {
            display: none;
        }

        /* Pagination */
        .swiper-pagination {
            position: absolute;
            text-align: center;
            transition: 0.3s opacity;
            transform: translate3d(0, 0, 0);
            z-index: 10;
        }

        .swiper-pagination.swiper-pagination-hidden {
            opacity: 0;
        }

        .swiper-pagination-disabled > .swiper-pagination,
        .swiper-pagination.swiper-pagination-disabled {
            display: none !important;
        }

        .swiper-horizontal > .swiper-pagination-bullets,
        .swiper-pagination-bullets.swiper-pagination-horizontal,
        .swiper-pagination-custom,
        .swiper-pagination-fraction {
            bottom: 10px;
            left: 0;
            width: 100%;
        }

        .swiper-pagination-bullets-dynamic {
            overflow: hidden;
            font-size: 0;
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
            transform: scale(0.33);
            position: relative;
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active {
            transform: scale(1);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main {
            transform: scale(1);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev {
            transform: scale(0.66);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev {
            transform: scale(0.33);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next {
            transform: scale(0.66);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next {
            transform: scale(0.33);
        }

        .swiper-pagination-bullet {
            width: var(--swiper-pagination-bullet-width, var(--swiper-pagination-bullet-size, 8px));
            height: var(--swiper-pagination-bullet-height, var(--swiper-pagination-bullet-size, 8px));
            display: inline-block;
            border-radius: 50%;
            background: var(--swiper-pagination-bullet-inactive-color, #000);
            opacity: var(--swiper-pagination-bullet-inactive-opacity, 0.2);
        }

        button.swiper-pagination-bullet {
            border: none;
            margin: 0;
            padding: 0;
            box-shadow: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .swiper-pagination-clickable .swiper-pagination-bullet {
            cursor: pointer;
        }

        .swiper-pagination-bullet:only-child {
            display: none !important;
        }

        .swiper-pagination-bullet-active {
            opacity: var(--swiper-pagination-bullet-opacity, 1);
            background: var(--swiper-pagination-color, var(--swiper-theme-color));
        }

        .swiper-vertical > .swiper-pagination-bullets,
        .swiper-pagination-vertical.swiper-pagination-bullets {
            right: 10px;
            top: 50%;
            transform: translate3d(0px, -50%, 0);
        }

        .swiper-vertical > .swiper-pagination-bullets .swiper-pagination-bullet,
        .swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet {
            margin: var(--swiper-pagination-bullet-vertical-gap, 6px) 0;
            display: block;
        }

        .swiper-vertical > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic,
        .swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
        }

        .swiper-vertical > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,
        .swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
            display: inline-block;
            transition: 0.2s transform, 0.2s top;
        }

        .swiper-horizontal > .swiper-pagination-bullets .swiper-pagination-bullet,
        .swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet {
            margin: 0 var(--swiper-pagination-bullet-horizontal-gap, 4px);
        }

        .swiper-horizontal > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic,
        .swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .swiper-horizontal > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,
        .swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
            transition: 0.2s transform, 0.2s left;
        }

        .swiper-horizontal.swiper-rtl > .swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
            transition: 0.2s transform, 0.2s right;
        }

        /* Scrollbar */
        .swiper-scrollbar {
            border-radius: 10px;
            position: relative;
            -ms-touch-action: none;
            touch-action: none;
            background: rgba(0, 0, 0, 0.1);
        }

        .swiper-scrollbar-disabled > .swiper-scrollbar,
        .swiper-scrollbar.swiper-scrollbar-disabled {
            display: none !important;
        }

        .swiper-horizontal > .swiper-scrollbar,
        .swiper-scrollbar.swiper-scrollbar-horizontal {
            position: absolute;
            left: 1%;
            bottom: 3px;
            width: 98%;
            height: 4px;
        }

        .swiper-vertical > .swiper-scrollbar,
        .swiper-scrollbar.swiper-scrollbar-vertical {
            position: absolute;
            right: 3px;
            top: 1%;
            width: 4px;
            height: 98%;
        }

        .swiper-scrollbar-drag {
            height: 100%;
            width: 100%;
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            left: 0;
            top: 0;
        }

        .swiper-scrollbar-cursor-drag {
            cursor: move;
        }

        .swiper-scrollbar-lock {
            display: none;
        }

        .swiper-zoom-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .swiper-zoom-container > img,
        .swiper-zoom-container > svg,
        .swiper-zoom-container > canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .swiper-slide-zoomed {
            cursor: move;
        }

        /* Preloader */
        .swiper-lazy-preloader {
            width: 42px;
            height: 42px;
            position: absolute;
            left: 50%;
            top: 50%;
            margin-left: -21px;
            margin-top: -21px;
            z-index: 10;
            transform-origin: 50%;
            box-sizing: border-box;
            border: 4px solid var(--swiper-preloader-color, var(--swiper-theme-color));
            border-radius: 50%;
            border-top-color: transparent;
        }

        .swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,
        .swiper-lazy-preloader {
            animation: swiper-preloader-spin 1s infinite linear;
        }

        .swiper-lazy-preloader-white {
            --swiper-preloader-color: #fff;
        }

        .swiper-lazy-preloader-black {
            --swiper-preloader-color: #000;
        }

        @keyframes swiper-preloader-spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .swiper .swiper-notification {
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: none;
            opacity: 0;
            z-index: -1000;
        }

        .swiper-free-mode > .swiper-wrapper {
            transition-timing-function: ease-out;
            margin: 0 auto;
        }

        .swiper-grid > .swiper-wrapper {
            flex-wrap: wrap;
        }

        .swiper-grid-column > .swiper-wrapper {
            flex-wrap: wrap;
            flex-direction: column;
        }

        .swiper-fade.swiper-free-mode .swiper-slide {
            transition-timing-function: ease-out;
        }

        .swiper-fade .swiper-slide {
            pointer-events: none;
            transition-property: opacity;
        }

        .swiper-fade .swiper-slide .swiper-slide {
            pointer-events: none;
        }

        .swiper-fade .swiper-slide-active,
        .swiper-fade .swiper-slide-active .swiper-slide-active {
            pointer-events: auto;
        }

        .swiper-cube {
            overflow: visible;
        }

        .swiper-cube .swiper-slide {
            pointer-events: none;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            z-index: 1;
            visibility: hidden;
            transform-origin: 0 0;
            width: 100%;
            height: 100%;
        }

        .swiper-cube .swiper-slide .swiper-slide {
            pointer-events: none;
        }

        .swiper-cube.swiper-rtl .swiper-slide {
            transform-origin: 100% 0;
        }

        .swiper-cube .swiper-slide-active,
        .swiper-cube .swiper-slide-active .swiper-slide-active {
            pointer-events: auto;
        }

        .swiper-cube .swiper-slide-active,
        .swiper-cube .swiper-slide-next,
        .swiper-cube .swiper-slide-prev,
        .swiper-cube .swiper-slide-next + .swiper-slide {
            pointer-events: auto;
            visibility: visible;
        }

        .swiper-cube .swiper-slide-shadow-top,
        .swiper-cube .swiper-slide-shadow-bottom,
        .swiper-cube .swiper-slide-shadow-left,
        .swiper-cube .swiper-slide-shadow-right {
            z-index: 0;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        .swiper-cube .swiper-cube-shadow {
            position: absolute;
            left: 0;
            bottom: 0px;
            width: 100%;
            height: 100%;
            opacity: 0.6;
            z-index: 0;
        }

        .swiper-cube .swiper-cube-shadow:before {
            content: '';
            background: #000;
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            right: 0;
            filter: blur(50px);
        }

        /* CSS Variables */
        :root {
            --swiper-theme-color: #007aff;
            --swiper-navigation-size: 44px;
            --swiper-navigation-top-offset: 50%;
            --swiper-navigation-sides-offset: 10px;
            --swiper-navigation-color: var(--swiper-theme-color);
            --swiper-pagination-color: var(--swiper-theme-color);
            --swiper-pagination-left: auto;
            --swiper-pagination-right: auto;
            --swiper-pagination-bottom: 8px;
            --swiper-pagination-top: auto;
            --swiper-pagination-fraction-color: inherit;
            --swiper-pagination-progressbar-bg-color: rgba(0, 0, 0, 0.25);
            --swiper-pagination-progressbar-size: 4px;
            --swiper-pagination-bullet-size: 8px;
            --swiper-pagination-bullet-width: 8px;
            --swiper-pagination-bullet-height: 8px;
            --swiper-pagination-bullet-inactive-color: #000;
            --swiper-pagination-bullet-inactive-opacity: 0.2;
            --swiper-pagination-bullet-opacity: 1;
            --swiper-pagination-bullet-horizontal-gap: 4px;
            --swiper-pagination-bullet-vertical-gap: 6px;
            --swiper-preloader-color: var(--swiper-theme-color);
            --swiper-wrapper-transition-timing-function: initial;
        }
    `;

    // Inject CSS
    const swiperStyleElement = document.createElement('style');
    swiperStyleElement.textContent = swiperCSS;
    if (document.head) {
        document.head.appendChild(swiperStyleElement);
    }

    // Attach to global
    if (typeof window !== 'undefined') {
        window.Swiper = Swiper;
    }

    return Swiper;
}));
